# GEE Longitudinal Extension Feasibility Report

**Phase:** 01.1-gee-longitudinal-feasibility
**Date:** 2026-02-03
**Status:** For Review

---

## 1. Executive Summary

**Can beeca accept GEE objects?** YES - with targeted S3 method extensions and variance routing changes.

**Recommendation:** **CONDITIONAL GO** - Proceed with **Phase 1 (minimal)** implementation that accepts GEE objects for single-timepoint covariate-adjusted analysis. This provides immediate value with minimal scope expansion while preserving beeca's identity as a focused, GxP-compliant package.

**Rationale:** Empirical tests confirm the core requirements work (predict with newdata, vcov extraction). The pipeline needs only 2-3 targeted changes to accept GEE objects. Multi-timepoint support requires substantially more complexity and represents scope creep inconsistent with beeca's "Binary Endpoint Estimation with Covariate Adjustment" identity. A companion package (e.g., `beecal`) is recommended for full longitudinal support if that need materializes.

**Key finding:** GEE objects can flow through beeca's g-computation pipeline with surgical modifications to input validation (sanitize_model) and variance estimation (route to GEE's own vcov instead of sandwich::vcovHC).

---

## 2. Empirical Test Results

### 2.1 Test Environment

From Plan 01 (01.1-01-SUMMARY.md), we created and executed feasibility-test.R with:
- 100 subjects × 4 visits = 400 observations
- Binary outcome (51.5% prevalence)
- Two treatment arms (A, B)
- Exchangeable correlation structure (within-subject)
- Baseline covariate adjustment
- Both glmtoolbox (glmgee) and geepack (geeglm) tested

### 2.2 What Works Out of the Box

| Component | glmgee | geeglm | Evidence |
|-----------|--------|--------|----------|
| **predict(newdata, type='response')** | ✓ PASS | ✓ PASS | Returns correct N×1 vector, values in [0,1] |
| **vcov(type='robust')** | ✓ PASS | ✓ PASS | Returns symmetric positive-definite matrix |
| **vcov(type='bias-corrected')** | ✓ PASS | N/A | Mancl-DeRouen correction available |
| **vcov(type='df-adjusted')** | ✓ PASS | N/A | Degrees-of-freedom adjustment available |
| **model.matrix()** | ✓ PASS | ✓ PASS | Design matrix extraction (400×4) |
| **.get_data()** | ✓ PASS | ✓ PASS | Both have model$model slot |

**Key observation:** Counterfactual predictions worked correctly with mean predictions differing by treatment arm (A=0.4852, B=0.5383).

### 2.3 What Needs Changes

| Component | Status | Error Message | Fix Required |
|-----------|--------|---------------|--------------|
| **sanitize_model()** | ✗ FAIL | "Model of class 'glmgee' is not supported" | Add S3 methods: sanitize_model.glmgee(), sanitize_model.geeglm() |
| **predict_counterfactuals()** | ✗ FAIL | Blocked by sanitize_model | Will work once sanitize extended |
| **average_predictions()** | ✗ FAIL | Blocked by predict_counterfactuals | Will work once predict_counterfactuals works |
| **estimate_varcov (Ge)** | ✗ FAIL | "no applicable method for 'estfun' applied to object of class 'glmgee'" | Route to vcov(gee_object, type='robust') instead of sandwich::vcovHC() |
| **estimate_varcov (Ye)** | ✗ FAIL | Same as Ge | Ye method NOT extensible (assumes independence) |

### 2.4 Compatibility Matrix

| beeca Function | glmgee | geeglm | Implementation Path |
|----------------|--------|--------|---------------------|
| Core predict() | works | works | Works directly (no changes) |
| Core vcov() | works | works | Works directly (no changes) |
| sanitize_model | fails | fails | Need S3 methods |
| predict_counterfactuals | fails | fails | Will work once sanitize_model extended |
| average_predictions | fails | fails | Will work once predict_counterfactuals works |
| estimate_varcov (Ge) | fails | fails | Route to vcov(gee, type='robust') |
| estimate_varcov (Ye) | fails | fails | NOT extensible |

### 2.5 Manual Ge Delta Method Test

From feasibility-test.R: Manual computation of Ge delta method with glmgee produced a valid 2×2 variance-covariance matrix for treatment arms A and B. This confirms the mathematical approach is sound once the variance extraction is corrected.

---

## 3. Architecture Assessment

### 3.1 What Works Without Changes

These beeca components work directly with GEE objects:

1. **predict(object, newdata, type="response")** - Both glmgee and geeglm implement this with correct API
2. **vcov(object)** - Both packages provide cluster-robust sandwich variance
3. **model.matrix(object)** - Standard S3 method works
4. **colMeans()** for averaging - Pure math operation, independent of object class
5. **Delta method contrasts** - apply_contrast.R logic is class-agnostic once variance matrix exists

### 3.2 What Needs New S3 Methods

File: `R/sanitize.R`

**Current situation:**
- sanitize_model() is an S3 generic (line 1)
- sanitize_model.glm() method checks glm-specific constraints (lines 8-86)
- No methods exist for glmgee or geeglm classes

**Required additions:**

```r
#' @export
sanitize_model.glmgee <- function(object, trt) {
  # Check family (binomial + logit)
  # Check treatment variable is factor
  # Check response is 0/1
  # Check convergence (object$converged)
  # Check no treatment-covariate interactions (RELAXED for Trt×Time)
  # Check no missing data
  # Check rank (use different method than $qr$rank)
}

#' @export
sanitize_model.geeglm <- function(object, trt) {
  # Similar checks adapted for geeglm structure
}
```

**Differences from glm method:**
1. GEE objects don't have `$qr$rank` - need alternative rank check (e.g., via model.matrix rank)
2. Family stored differently (glmgee: `$family`, geeglm: `$family`)
3. Convergence flag location differs (glmgee: `$converged`, geeglm: `$converged`)
4. **CRITICAL:** For longitudinal GEE, Treatment×Time interactions MUST be allowed (current sanitize_model.glm blocks all treatment interactions)

**Estimated change:** ~80 lines of new code across two S3 methods

### 3.3 What Needs Redesign

File: `R/estimate_varcov.R`

**Ge method (lines 30-65):**

Current implementation:
```r
varcov_ge <- function(object, type = "HC3") {
  V <- sandwich::vcovHC(object, type = type)
  # ... delta method ...
}
```

**Problem:** sandwich::vcovHC() requires estfun() method, which doesn't exist for GEE objects. The GEE's own robust sandwich is fundamentally different - it accounts for within-cluster correlation.

**Required change:**
```r
varcov_ge <- function(object, type = "HC3") {
  # Dispatch based on object class
  if (inherits(object, "glmgee")) {
    # glmtoolbox provides vcov with type argument
    # type="robust" -> standard sandwich
    # type="bias-corrected" -> Mancl-DeRouen
    # type="df-adjusted" -> DF correction
    V <- vcov(object, type = translate_type_glmgee(type))
  } else if (inherits(object, "geeglm")) {
    # geepack only has basic robust sandwich
    V <- vcov(object)
  } else {
    # Existing glm path
    V <- sandwich::vcovHC(object, type = type)
  }
  # ... rest of delta method unchanged ...
}
```

**Translation mapping:**
- HC0, HC1, HC2, HC3 -> "robust" (standard GEE sandwich)
- HC4, HC4m, HC5 -> "bias-corrected" (Mancl-DeRouen, closest analog)
- "model" -> "model" (naive variance, not recommended)

**Estimated change:** ~50 lines (conditional logic + type translation function)

**Ye method (lines 67-124):**

The Ye et al. (2023) variance decomposition was derived specifically for independent observations. It computes variance using:
- Per-observation residuals
- Counterfactual predictions
- Assumes V(Y_i) independent across i

**For GEE:** Observations within a cluster are NOT independent. The Ye derivation does not extend to clustered data without a fundamental re-derivation accounting for within-cluster correlation structure.

**Decision:** Disable Ye method for GEE objects. In sanitize_model.glmgee/geeglm, set an attribute like `attr(object, "ye_compatible") <- FALSE`, then check this in estimate_varcov and error with informative message:

```r
if (method == "Ye" && !isTRUE(attr(object, "ye_compatible"))) {
  stop("Ye variance method not supported for GEE models. Use method='Ge'.")
}
```

**Estimated change:** ~10 lines (attribute check + error)

### 3.4 What Is Not Applicable

1. **Ye variance method** - Not extensible to clustered data
2. **HC0-HC5 types** - These are single-observation corrections; GEE has different correction framework
3. **Multi-timepoint marginal effects** - Not in scope for Phase 1 (see Section 5)
4. **Treatment-covariate interactions** - Blocked in current sanitize_model.glm, must remain blocked for GEE in Phase 1

---

## 4. Methodology Assessment

### 4.1 Ge Delta Method Extension

**Current approach (glm):**
1. Fit working model: `glm(Y ~ Trt + Covariates, family=binomial)`
2. Generate counterfactuals: predict under each treatment
3. Average counterfactuals: colMeans per treatment
4. Compute gradient D: derivatives of means w.r.t. model parameters
5. Variance: `D × vcovHC(glm) × D'` where vcovHC is HC0/HC1/HC2/HC3/HC4/HC4m/HC5/model
6. Contrast: delta method on treatment difference

**Extension to GEE:**
1. Fit working model: `glmgee(Y ~ Trt + Covariates, id=ID, family=binomial, corstr="exchangeable")`
2. Generate counterfactuals: predict under each treatment (SAME as glm)
3. Average counterfactuals: colMeans per treatment (SAME as glm)
4. Compute gradient D: derivatives of means w.r.t. model parameters (SAME as glm)
5. Variance: `D × vcov(glmgee, type='robust') × D'` where vcov is GEE cluster-robust sandwich
6. Contrast: delta method on treatment difference (SAME as glm)

**Key insight:** Steps 2-4 and 6 are IDENTICAL. Only step 5 (variance extraction) changes. The GEE's vcov() method already computes the cluster-robust sandwich estimator that accounts for within-cluster correlation.

**Mathematical validity:** The delta method propagation of uncertainty from parameters to marginal means is the same whether parameters came from glm or GEE. The GEE sandwich accounts for correlation in the parameter estimates; propagating that through g-computation is methodologically sound.

### 4.2 Mancl-DeRouen Correction

The Mancl-DeRouen (2001) correction is a small-sample bias correction for the GEE sandwich variance. It inflates residuals by the inverse leverage:

```
V_MDR = B^-1 × [Σ_i D_i' V_i^-1 H_i (Y_i - μ_i)(Y_i - μ_i)' H_i V_i^-1 D_i] × B^-1
where H_i = (I - H_i)^-1
```

This is analogous to HC3 in the single-observation case.

**For beeca + GEE:** The Mancl-DeRouen correction comes FOR FREE via `vcov(glmgee_object, type="bias-corrected")`. glmtoolbox implements this internally. The beeca code doesn't need to compute it - just route to the correct vcov() call.

**User experience:**
```r
fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial, data=d) |>
  get_marginal_effect(trt="trtp", method="Ge", type="bias-corrected")
```

The `type` argument gets passed to vcov(glmgee, type="bias-corrected").

### 4.3 Treatment × Time Interactions

Current beeca (R/sanitize.R lines 50-55) blocks ALL treatment interactions:

```r
if (any(grepl(trt_interaction_pattern, terms_labels))) {
  stop("Model cannot include treatment-covariate interactions")
}
```

**For single-timepoint GEE:** This restriction MUST remain. Treatment-covariate interactions break the g-computation assumption of a common working model.

**For multi-timepoint GEE (future):** Treatment×Time interactions are ESSENTIAL. The model is:

```r
glmgee(Y_it ~ Trt + Time + Trt:Time + Covariates, id=ID, ...)
```

The Trt:Time interaction estimates timepoint-specific treatment effects. Without it, you assume constant treatment effect across time.

**Phase 1 decision:** Keep interaction block in place. Phase 1 only supports single-timepoint analysis where time is not in the model.

### 4.4 Why Not Ye Method?

The Ye et al. (2023) variance decomposition is:

```
Var(hat{μ}_k) = Var_W[E_θ(hat{μ}_k | W)] + E_W[Var_θ(hat{μ}_k | W)]
```

where W = (Y, X) are the observed data and θ are the model parameters.

**Key assumption:** E_W and Var_W treat observations as independent. The outer expectation and variance are over N independent draws.

**For GEE:** Observations within a cluster are NOT independent. The variance decomposition would need to account for:
1. Between-cluster variance (as in Ye)
2. Within-cluster covariance (new term)

This is a fundamental re-derivation that doesn't exist in the published literature. The Ge/delta-method approach sidesteps this by using the GEE's own cluster-robust variance for parameters.

**Practical impact:** Users of GEE objects can only use `method="Ge"`, not `method="Ye"`. This is an acceptable limitation - Ge is the primary method in beeca and is methodologically sound for GEE.

---

## 5. Scope Options

### Option A: Minimal - Accept GEE for Single-Timepoint (IN BEECA)

**What it does:**
- Adds sanitize_model.glmgee() and sanitize_model.geeglm() S3 methods
- Routes Ge variance to vcov(gee_object, type=...) instead of sandwich::vcovHC()
- Disables Ye method for GEE objects with informative error
- No multi-timepoint support (user extracts single timepoint themselves)
- No Treatment×Time interactions (keep existing block)
- Existing ARD output format unchanged

**Use case:**
User has clustered data (e.g., site-level clustering) and wants covariate-adjusted marginal effects at a single endpoint. They fit a GEE to handle clustering, then pass the model to beeca.

**Example:**
```r
# User fits GEE on single-timepoint data with site clustering
fit <- glmgee(aval ~ trtp + bl_cov, id=site_id, family=binomial, data=trial) |>
  get_marginal_effect(trt="trtp", method="Ge", type="bias-corrected")

# Mancl-DeRouen variance correction included via type="bias-corrected"
fit$marginal_results  # Standard ARD format
```

**Files modified:**
1. `R/sanitize.R` - Add sanitize_model.glmgee() and sanitize_model.geeglm()
2. `R/estimate_varcov.R` - Add conditional logic to route to vcov(gee) instead of sandwich::vcovHC()
3. `R/estimate_varcov.R` - Add Ye method check and error for GEE objects

**Estimated effort:**
- Code: ~150 lines new, ~30 lines modified
- Testing: New test file test-gee-sanitize.R (~100 lines), additions to test-estimate_varcov.R (~150 lines)
- Documentation: Update sanitize_model.Rd, estimate_varcov.Rd, add GEE example to vignette
- Cross-validation: Compare against manual Ge computation (already tested in feasibility-test.R)
- Total time: 1-2 days coding + 1 day testing + 0.5 day documentation = **2.5-3.5 days**

**Estimated testing burden:**
- Medium - Need to test both glmgee and geeglm objects through full pipeline
- Need to verify Mancl-DeRouen correction matches manual computation
- Need to verify Ye method error is clear and informative
- Test coverage target: 95%+ for new S3 methods

**Pros:**
- Minimal scope expansion - beeca remains "Binary Endpoint Estimation"
- Immediate value for clustered data use cases
- Mancl-DeRouen correction comes free via glmtoolbox
- Low maintenance burden (2 new S3 methods + 1 conditional)
- Preserves package identity and focus
- GxP validation burden minimal (localized changes)

**Cons:**
- Doesn't address full longitudinal use case from user request
- User must subset data to single timepoint themselves
- No multiplicity adjustment across timepoints

**Recommendation:** **YES** - This is the right balance of value and scope for beeca.

---

### Option B: Moderate - Multi-Timepoint Support (IN BEECA)

**What it does:**
- Everything in Option A
- Extend predict_counterfactuals() to generate timepoint-stratified predictions
- Extend average_predictions() to produce treatment × timepoint means matrix
- Extend apply_contrast() to compute contrasts per timepoint
- Extend ARD output with AVISIT/timepoint dimension
- Allow Treatment×Time interactions in sanitize_model for GEE

**Use case:**
User has longitudinal binary data with multiple visits and wants covariate-adjusted marginal effects at each timepoint, with joint variance-covariance matrix for multiplicity adjustment.

**Example:**
```r
fit <- glmgee(aval ~ trtp + visit + trtp:visit + bl_cov,
              id=subject_id, family=binomial, data=long_trial) |>
  get_marginal_effect(trt="trtp", timepoint="visit", method="Ge")

# Returns marginal effects at each visit with joint variance-covariance
fit$marginal_est  # Vector: [diff_v1, diff_v2, diff_v3, diff_v4]
fit$robust_varcov  # 4×4 matrix accounting for within-subject correlation
```

**Files modified:**
1. All files from Option A
2. `R/predict_counterfactuals.R` - Add timepoint argument, loop over timepoint levels
3. `R/average_predictions.R` - Stratify by timepoint, return matrix not vector
4. `R/apply_contrast.R` - Extend delta method to handle timepoint dimension
5. `R/get_marginal_effect.R` - Add timepoint argument to main wrapper
6. `R/ard.R` (if exists) or ARD construction code - Add AVISIT column
7. `R/sanitize.R` - Relax interaction check to allow Trt×Time

**Estimated effort:**
- Code: ~400 lines new, ~100 lines modified
- Testing: New test file test-gee-longitudinal.R (~300 lines), major additions to existing tests
- Documentation: Update 5+ .Rd files, new vignette section or separate vignette
- Cross-validation: Need to validate against published longitudinal GEE + g-computation examples (if they exist)
- Total time: 1 week coding + 1 week testing + 1 week documentation/cross-validation = **3 weeks**

**Estimated testing burden:**
- Large - Many edge cases:
  - Unbalanced visits (not all subjects have all timepoints)
  - Monotone dropout patterns
  - Time-varying covariates
  - Different correlation structures (exchangeable, AR(1), unstructured)
  - Treatment × timepoint interactions with multiple timepoints
  - ARD format with timepoint dimension
- Test coverage target: 95%+ but much more complex test matrix

**Pros:**
- Addresses full longitudinal use case
- Provides joint variance-covariance for multiplicity adjustment
- No existing R package provides this combination (GEE + g-computation + clinical trial ARD output)
- Regulatory value (covariate adjustment + longitudinal)

**Cons:**
- **Significant scope creep** - beeca is "Binary Endpoint Estimation", not "Longitudinal Binary Endpoint Estimation"
- 3 weeks of development = high opportunity cost vs. other package priorities
- Testing complexity high - GxP validation burden increases substantially
- Maintenance burden increases (5+ files with longitudinal logic)
- Package identity diluted - longitudinal is a different domain
- **User's actual need unclear** - do they need g-computation on GEE or is direct GEE estimation sufficient?

**Recommendation:** **NO** - This belongs in a companion package.

---

### Option C: Full - Companion Package (BEECAL or similar)

**What it does:**
- Everything in Options A and B
- MVT-based multiplicity adjustment using joint variance-covariance
- Gatekeeping procedures for hierarchical testing
- Firth-penalised GEE support via geesbin
- Ordinal GEE extension (proportional odds) - future
- Separate DESCRIPTION, separate test suite, separate validation
- beeca imports beecal for users who need longitudinal features

**Package name:** `beecal` ("Binary Endpoint Estimation with Covariate Adjustment - Longitudinal")

**Use case:**
Complex longitudinal clinical trials with binary/ordinal endpoints, requiring:
- Covariate-adjusted marginal effects at multiple timepoints
- Robust variance with small-sample corrections
- Multiplicity adjustment across timepoints (MVT, gatekeeping)
- Firth correction for rare events

**Example:**
```r
library(beecal)

fit <- glmgee(aval ~ trtp + visit + trtp:visit + bl_cov,
              id=subject_id, family=binomial, data=long_trial) |>
  get_longitudinal_effect(trt="trtp", timepoint="visit", method="Ge") |>
  adjust_multiplicity(method="mvt", alpha=0.025)

fit$adjusted_pvalues  # MVT-adjusted p-values per timepoint
```

**Estimated effort:**
- New package setup: 1 week (DESCRIPTION, documentation infrastructure, GitHub, CI/CD)
- Core pipeline (Options A+B): 3 weeks (as above)
- Multiplicity adjustment: 1-2 weeks (mvtnorm integration, gatekeeping procedures)
- Firth-penalised GEE: 1 week (accept geesbin objects, test)
- Total time: **6-7 weeks**

**Pros:**
- Separates concerns - beeca stays focused, beecal handles longitudinal
- Can grow independently (ordinal, survival extensions in future)
- Separate versioning and release cycle
- Separate GxP validation - beeca remains stable while beecal evolves
- **Allows experimentation** - beecal can be more cutting-edge without risking beeca's stability
- Clear package identity: beecal = longitudinal, beeca = cross-sectional

**Cons:**
- 6-7 weeks to deliver full functionality
- Need to maintain two packages
- User must install both packages
- Code duplication vs. shared infrastructure (though beecal would import beeca)
- beecal would start with small user base

**Recommendation:** **IF GO** on multi-timepoint, **THEN** use this option. But defer decision until user need is confirmed.

---

## 6. Recommendation

### Primary Recommendation: CONDITIONAL GO - Option A (Minimal)

**Implement Phase 1 (Option A) in beeca:**
1. Add S3 methods: sanitize_model.glmgee() and sanitize_model.geeglm()
2. Route Ge variance to vcov(gee_object, type=...) instead of sandwich::vcovHC()
3. Disable Ye method for GEE with informative error
4. Document GEE support for single-timepoint analysis with Mancl-DeRouen correction

**Rationale:**

1. **Empirical evidence is strong:** Tests confirm predict() and vcov() work perfectly. The changes are surgical and low-risk.

2. **Immediate value:** Users with clustered data (site-level, center-level) can use GEE for single-endpoint analysis with covariate adjustment. Mancl-DeRouen correction addresses the small-sample concern from the user request.

3. **Minimal scope expansion:** beeca remains "Binary Endpoint Estimation with Covariate Adjustment". We're adding support for a different fitting method (GEE vs. glm), not changing the core use case (single binary endpoint).

4. **Low maintenance burden:** Two S3 methods + one conditional in estimate_varcov. Testing is medium complexity (not high). GxP validation is localized.

5. **Preserves package identity:** The name "beeca" and the package description remain accurate. We're not becoming a longitudinal package.

6. **Aligns with beeca philosophy:** Lightweight, focused, GxP-compliant. Option A preserves all three.

**DEFER multi-timepoint support** until:
- User confirms they need g-computation on top of GEE (vs. direct GEE estimation)
- Companion package (beecal) is scoped and resourced
- RobinCar longitudinal features are evaluated as alternative

### Why Not Option B (Multi-Timepoint in beeca)?

1. **Scope creep:** 5+ files modified, 400+ lines new, 3 weeks development. This is a major feature, not a minor extension.

2. **Package identity:** beeca is "Binary Endpoint Estimation" - singular. Longitudinal introduces a time dimension that changes the core use case.

3. **Testing complexity:** Unbalanced visits, dropout, time-varying covariates = large test matrix. GxP validation burden increases substantially.

4. **User need unclear:** The original request mentions GEE and longitudinal together, but it's unclear if they need g-computation on GEE or if direct GEE estimation (with emmeans or marginaleffects for contrasts) would suffice.

5. **Maintenance burden:** 5+ files with longitudinal logic = long-term maintenance commitment. Every future beeca feature must consider longitudinal compatibility.

6. **Opportunity cost:** 3 weeks = cost of multiple other enhancements (e.g., ordinal endpoints at single timepoint, more robust ARD features, integration with other reporting tools).

### Why Not Option C (Companion Package)?

**IF** multi-timepoint support is needed, **THEN** Option C (companion package) is the right path. But that's a decision for after:
1. User confirms need for full longitudinal support
2. Team assesses resource availability (6-7 weeks)
3. Evaluation of RobinCar's longitudinal features as alternative

For now, **defer** this option.

---

## 7. Risk Assessment

### Option A Risks (Minimal)

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| glmgee/geeglm API changes break our code | Low | Medium | Pin to current versions in Suggests, test with multiple versions |
| Mancl-DeRouen implementation differs from published method | Low | Medium | Cross-validate against manual computation (already done in feasibility test) |
| Users try to use multi-timepoint data, get confusing errors | Medium | Low | Add clear error message in sanitize_model: "GEE objects only supported for single-timepoint analysis in beeca. For longitudinal, see beecal package." |
| Ye method error message not clear enough | Low | Low | Write detailed error with link to documentation explaining why Ye doesn't extend |
| Rank check for GEE objects doesn't work | Medium | Medium | Test multiple rank scenarios, use model.matrix rank as fallback |

### Option B Risks (Multi-Timepoint)

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Unbalanced visit patterns break averaging logic | High | High | Extensive testing of dropout scenarios |
| ARD format extension not compatible with downstream tools | Medium | High | Consult with CDISC experts before finalizing format |
| Time-varying covariates not handled correctly | Medium | High | Clear documentation of supported covariate types, error if detected |
| Multiplicity adjustment expectations exceed what we deliver | Medium | Medium | Clear scoping: we provide joint variance-covariance, user applies MVT themselves or uses beecal |
| Testing burden overwhelms development timeline | High | High | Phase testing: core functionality first, edge cases incrementally |

### Option C Risks (Companion Package)

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Two packages to maintain = double the burden | High | Medium | Share infrastructure (beecal imports beeca), separate release cycles |
| User confusion about which package to use | Medium | Low | Clear documentation, beeca README points to beecal for longitudinal |
| beecal doesn't get enough users to justify maintenance | Medium | Medium | Start with minimal viable product, grow based on demand |
| Code duplication vs. shared infrastructure tension | Medium | Low | beecal imports beeca, extends rather than duplicates |

### What We Still Don't Know

1. **Does the user actually need g-computation on GEE?** Or would direct GEE estimation (with emmeans or marginaleffects for contrasts) meet their need? The original request conflates several features without explaining why g-computation specifically.

2. **How common is this use case?** Are there other users requesting longitudinal + covariate adjustment + g-computation? Or is this a niche need?

3. **What does RobinCar offer?** RobinCar (in beeca's Suggests) is developing longitudinal extensions. Would pointing users to RobinCar meet the need?

4. **Regulatory landscape:** Do sponsors actually use g-computation + GEE in regulatory submissions? Or is GEE direct estimation the standard? Anecdotal evidence from the user would help.

### Dependencies on External Packages

| Package | Current Status | Option A | Option B/C | Stability Concern |
|---------|----------------|----------|------------|-------------------|
| glmtoolbox | Not in beeca | Suggests | Suggests or Imports | Medium - maintained by single author, but recent (2023) |
| geepack | Not in beeca | Suggests | Suggests or Imports | HIGH - maintenance concerns, possible abandonment, open bugs |
| sandwich | Imports | Imports | Imports | Low - mature, stable |
| geesbin | Not in beeca | Not needed | Suggests | Medium - new (2024), small user base |
| mvtnorm | Not in beeca | Not needed | Imports | Low - mature, stable |

**Recommendation:** For Option A, add glmtoolbox to Suggests (primary), geepack to Suggests (secondary). Document that glmtoolbox is recommended over geepack due to Mancl-DeRouen support and maintenance status.

---

## 8. Next Steps

### If GO - Option A (Minimal)

**Roadmap addition:**

**Phase 1.1.1: Implement GEE S3 Methods (1 day)**
- Task 1: Add sanitize_model.glmgee() to R/sanitize.R
- Task 2: Add sanitize_model.geeglm() to R/sanitize.R
- Task 3: Test both methods with feasibility-test.R data

**Phase 1.1.2: Route Ge Variance to GEE vcov (1 day)**
- Task 1: Add conditional logic in estimate_varcov.R varcov_ge()
- Task 2: Add type translation function for glmgee variance types
- Task 3: Test Ge variance matches manual computation

**Phase 1.1.3: Disable Ye Method for GEE (0.5 day)**
- Task 1: Add ye_compatible attribute check
- Task 2: Add informative error message
- Task 3: Test error is clear

**Phase 1.1.4: Testing and Documentation (1 day)**
- Task 1: Create test-gee-sanitize.R and test-gee-varcov.R
- Task 2: Add GEE example to vignette
- Task 3: Update sanitize_model.Rd and estimate_varcov.Rd
- Task 4: Add NEWS.md entry for v0.3.0

**Total: 3.5 days** (aligns with estimate from Section 5)

**Deliverables:**
- GEE objects accepted for single-timepoint analysis
- Mancl-DeRouen correction available via type="bias-corrected"
- Clear error for Ye method with GEE
- Documentation with GEE examples
- Test coverage 95%+

### If NO-GO

**Alternative recommendations:**

1. **Point users to marginaleffects:** The {marginaleffects} package supports GEE objects and can compute marginal effects. It doesn't use g-computation but provides similar functionality.

2. **Point users to RobinCar:** RobinCar is developing longitudinal covariate adjustment features. Wait for their implementation to mature.

3. **Provide manual computation example:** Document how to manually compute g-computation on GEE using beeca's internal functions in combination with GEE model fitting. Users with advanced needs can use this approach without formal beeca support.

### If CONDITIONAL (Our Recommendation)

**Proceed with Option A, defer Option B/C pending:**

1. **User clarification:** Ask the user:
   - Do you need g-computation specifically, or would direct GEE estimation meet your needs?
   - Is multi-timepoint support essential, or can you analyze timepoints separately?
   - Have you tried marginaleffects or RobinCar for this use case?

2. **Community feedback:** After Option A is released (beeca v0.3.0), solicit feedback:
   - How many users adopt GEE support?
   - Do users request multi-timepoint extension?
   - What does the use case data show?

3. **RobinCar evaluation:** Review RobinCar's longitudinal features when available. If RobinCar provides g-computation + GEE + longitudinal, beeca doesn't need to duplicate.

4. **Resource assessment:** If multi-timepoint demand is confirmed, assess team capacity for 6-7 week companion package project.

**Timeline:**
- Phase 1 (Option A): Implement in current release (v0.3.0) - 3.5 days
- Defer Phase 2 decision: 6 months post-release
- Reassess based on user feedback and RobinCar landscape

---

## Appendix: Phase Success Criteria Verification

### Criterion 1: Feasibility Report Produced
✓ This document

### Criterion 2: Tested with glmtoolbox and/or geepack
✓ Plan 01 (feasibility-test.R) tested both glmgee and geeglm objects
- Confirmed predict(newdata) works: ✓
- Confirmed vcov(type='robust') works: ✓
- Confirmed vcov(type='bias-corrected') works for glmgee: ✓
- Documented compatibility matrix: ✓
- Test dataset created with realistic within-subject correlation: ✓

### Criterion 3: Go/No-Go Recommendation with Clear Rationale
✓ **CONDITIONAL GO - Option A (Minimal)**

Rationale:
1. Empirical evidence confirms core requirements work
2. Changes are surgical and low-risk (~150 lines new code, 2 files modified)
3. Immediate value for clustered data use cases
4. Mancl-DeRouen correction comes free via glmtoolbox
5. Preserves beeca's identity as focused, GxP-compliant package
6. Minimal maintenance and testing burden
7. Defers multi-timepoint until user need is confirmed

### Criterion 4: If Go - Scoped Implementation Plan
✓ Section 8 provides:
- 4 implementation phases (1.1.1 through 1.1.4)
- Task breakdown per phase
- Time estimates (3.5 days total)
- Deliverables defined
- Test coverage target (95%+)
- Documentation requirements

---

**END OF REPORT**

**Status:** READY FOR REVIEW
**Next Action:** User review and approval of recommendation
**If Approved:** Proceed to Phase 1.1.1 (implement GEE S3 methods)
