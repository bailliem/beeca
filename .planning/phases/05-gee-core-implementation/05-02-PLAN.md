---
phase: 05-gee-core-implementation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - R/estimate_varcov.R
  - R/get_marginal_effect.R
autonomous: true

must_haves:
  truths:
    - "estimate_varcov with a GEE object uses GEE's own vcov (not sandwich::vcovHC)"
    - "GEE variance types use GEE-native names (robust, bias-corrected, df-adjusted), not HC0/HC1/etc."
    - "Passing HC0 to a GEE object produces an error listing valid GEE types"
    - "method='Ye' with a GEE object produces: Ye's method assumes independence and is not valid for GEE models. Use method='Ge' instead."
    - "get_marginal_effect works end-to-end with glmgee for all five contrast types"
    - "get_marginal_effect works end-to-end with geeglm for all five contrast types"
  artifacts:
    - path: "R/estimate_varcov.R"
      provides: "GEE variance routing via varcov_ge_gee internal function"
      contains: "varcov_ge_gee"
    - path: "R/estimate_varcov.R"
      provides: "Ye method rejection for GEE"
      contains: "Ye's method assumes independence"
    - path: "R/get_marginal_effect.R"
      provides: "End-to-end pipeline for GEE objects with .get_formula() helper"
      contains: ".get_formula"
  key_links:
    - from: "R/estimate_varcov.R"
      to: "vcov(object, type = ...)"
      via: "GEE-native vcov call instead of sandwich::vcovHC"
      pattern: "vcov\\(object.*type"
    - from: "R/estimate_varcov.R"
      to: "varcov_ge"
      via: "delta method reuse -- same d_list computation, different V source"
      pattern: "all_d.*%\\*%.*V.*%\\*%.*t\\(all_d\\)"
    - from: "R/get_marginal_effect.R"
      to: "R/estimate_varcov.R"
      via: "pipeline passes GEE object through estimate_varcov"
      pattern: "estimate_varcov"
    - from: "R/get_marginal_effect.R"
      to: "object$formula"
      via: ".get_formula() helper guarantees formula access for both GEE classes"
      pattern: "\\.get_formula\\(object\\)"
---

<objective>
Add GEE variance routing to estimate_varcov and verify the end-to-end pipeline produces correct marginal treatment effects for GEE objects across all five contrast types.

Purpose: This completes the GEE core implementation. Plan 01 opened the gate (validation). This plan wires the variance estimation correctly and confirms the full pipeline works: GEE object -> predict_counterfactuals -> average_predictions -> estimate_varcov -> apply_contrast -> marginal results.

Output: Modified estimate_varcov.R with GEE routing, .get_formula() helper in get_marginal_effect.R, verified end-to-end pipeline.
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gee-core-implementation/05-CONTEXT.md
@.planning/phases/05-gee-core-implementation/05-RESEARCH.md
@.planning/phases/05-gee-core-implementation/05-01-SUMMARY.md
@R/estimate_varcov.R
@R/get_marginal_effect.R
@R/sanitize.R
@R/predict_counterfactuals.R
@R/apply_contrast.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GEE variance routing to estimate_varcov</name>
  <files>R/estimate_varcov.R</files>
  <action>
Modify estimate_varcov() and add a new internal function varcov_ge_gee() for GEE variance estimation. The changes are surgical -- the delta method math is identical to existing varcov_ge(), only the V (variance-covariance of coefficients) source changes.

**Changes to estimate_varcov():**

1. After `method <- match.arg(method)`, add early Ye rejection for GEE objects:
   ```r
   if (method == "Ye" && (inherits(object, "glmgee") || inherits(object, "geeglm"))) {
     stop("Ye's method assumes independence and is not valid for GEE models. Use method='Ge' instead.",
          call. = FALSE)
   }
   ```
   This exact message is a locked user decision. Do not modify it.

2. In the `method == "Ge"` branch, BEFORE calling match.arg(type) with the GLM HC types, detect GEE objects and route differently:
   ```r
   if (method == "Ge") {
     if (inherits(object, "glmgee") || inherits(object, "geeglm")) {
       # GEE objects use GEE-native variance types, not HC types
       varcov <- varcov_ge_gee(object, trt, type)
     } else {
       type <- match.arg(type)
       if (!is.null(strata)) {
         warning("Strata is supplied but will be ignored when using method='Ge'", call. = FALSE)
       }
       varcov <- varcov_ge(object, trt, type)
     }
   }
   ```

3. Update the type attribute on robust_varcov to reflect GEE type names:
   The existing line `attr(object$robust_varcov, "type") <- ifelse(method == "Ge", paste0(method, " - ", type), method)` should still work because `type` will contain the GEE-native type name.

**Also handle strata warning for GEE:**

If strata is supplied with a GEE object, warn that it's ignored (same as existing Ge method behavior). Add this inside the GEE branch, before calling varcov_ge_gee:
```r
if (!is.null(strata)) {
  warning("Strata is supplied but will be ignored when using method='Ge'", call. = FALSE)
}
```

**New internal function varcov_ge_gee():**

```r
## GEE-specific Ge delta method variance
## Uses GEE's own vcov instead of sandwich::vcovHC
varcov_ge_gee <- function(object, trt, type) {
  data <- .get_data(object)

  # Determine valid variance types based on GEE class
  if (inherits(object, "glmgee")) {
    valid_types <- c("robust", "bias-corrected", "df-adjusted")
    default_type <- "robust"
    class_name <- "glmgee"
  } else if (inherits(object, "geeglm")) {
    valid_types <- c("robust")
    default_type <- "robust"
    class_name <- "geeglm"
  }

  # --- Type resolution (single algorithm) ---
  # The estimate_varcov() signature has type = c("HC0", "model-based", ...) as default.
  # When the user does NOT specify type, R passes the full default vector (length > 1).
  # When the user DOES specify type, R passes a single string (length == 1).
  glm_types <- c("HC0", "model-based", "HC3", "HC", "HC1", "HC2", "HC4", "HC4m", "HC5")

  if (length(type) > 1) {
    # User did not specify type -- use GEE default silently
    type <- default_type
  } else if (type %in% glm_types) {
    # User explicitly passed a GLM-style type name -- error with valid GEE types
    stop(sprintf(
      'Variance type "%s" is not supported for %s objects. Valid types: %s',
      type, class_name, paste(valid_types, collapse = ", ")
    ), call. = FALSE)
  } else if (!type %in% valid_types) {
    # User passed an unrecognized type -- error with valid GEE types
    stop(sprintf(
      'Variance type "%s" is not supported for %s objects. Valid types: %s',
      type, class_name, paste(valid_types, collapse = ", ")
    ), call. = FALSE)
  }
  # If we reach here, type is a valid GEE type name
  # --- End type resolution ---

  # Get GEE's own variance-covariance matrix of coefficients
  if (inherits(object, "geeglm")) {
    # geeglm: vcov() returns the sandwich variance from fitting
    # The type is determined by std.err at fit time, so just use vcov()
    V <- stats::vcov(object)
  } else {
    # glmgee: vcov(object, type = ...) supports multiple types
    V <- vcov(object, type = type)
  }

  # Delta method -- IDENTICAL to existing varcov_ge() from here
  # Uses .get_formula() for safe formula access across GEE classes
  cf_pred <- object$counterfactual.predictions
  frm <- .get_formula(object)

  d_list <- list()
  for (trtlvl in levels(data[[trt]])) {
    X_i <- data
    X_i[, trt] <- factor(trtlvl, levels = levels(data[[trt]]))
    X_i <- model.matrix(frm, X_i)

    pderiv_i <- cf_pred[, trtlvl] * (1 - cf_pred[, trtlvl])
    d_i <- (t(pderiv_i) %*% as.matrix(X_i)) / nrow(X_i)
    d_list[[trtlvl]] <- d_i
  }

  all_d <- do.call(rbind, d_list)
  varcov <- all_d %*% V %*% t(all_d)
  rownames(varcov) <- colnames(varcov) <- levels(data[[trt]])

  return(varcov)
}
```

Note: This function uses `.get_formula()` (created in Task 2) instead of `object$formula` directly. This ensures formula access works for both glmgee and geeglm. Since Task 1 and Task 2 are in the same plan and edit different files, the executor should implement Task 2 first (or at minimum, add `.get_formula()` early in Task 1 if editing estimate_varcov.R first). Alternatively, if implementing Task 1 first, temporarily use `object$formula` and then replace with `.get_formula(object)` after Task 2 adds the helper. Either order works -- the verification will catch any issues.

**Design decisions (Claude's discretion per CONTEXT.md):**
- Default variance type for GEE: "robust" (matches sandwich HC0 philosophy, consistent recommendation from research)
- geeglm variance: expose only "robust" (native geepack sandwich SE). The std.err type is set at fit time, and vcov() returns whatever was specified. Exposing only "robust" avoids confusion.
- glmgee variance: expose "robust", "bias-corrected", "df-adjusted" (all three work per feasibility testing; "model" and "jackknife" omitted for simplicity)
- Type mapping: when user doesn't specify type (length > 1 = raw default vector), silently map to "robust". When user explicitly passes a GLM type (HC0, HC3, etc.), error with valid options list.
- vcov extraction: use vcov() method call (not object internals) -- cleaner, more future-proof
  </action>
  <verify>
1. Run `Rscript -e "devtools::load_all('.'); library(glmtoolbox); set.seed(42); n <- 50; d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5)); fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d, corstr='independence'); result <- fit |> predict_counterfactuals('trtp') |> average_predictions() |> estimate_varcov(method='Ge'); cat('glmgee varcov computed\n'); print(result[['robust_varcov']])"` -- should print a 2x2 variance-covariance matrix.

2. Test Ye rejection: `Rscript -e "devtools::load_all('.'); library(glmtoolbox); set.seed(42); n <- 50; d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5)); fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d, corstr='independence'); result <- fit |> predict_counterfactuals('trtp') |> average_predictions(); tryCatch(estimate_varcov(result, method='Ye'), error=function(e) cat('Error:', e[['message']], '\n'))"` -- should print the Ye rejection message.

3. Test GLM type rejection: similar test passing `type='HC3'` to a GEE object -- should error with valid types list.

4. Run `Rscript -e "devtools::test('.')"` -- all existing tests pass.
  </verify>
  <done>
- estimate_varcov routes GEE objects to varcov_ge_gee() which uses GEE's own vcov
- Ye method with GEE produces exact locked error message
- GLM variance types (HC0, HC3, etc.) rejected for GEE with valid options listed
- Default type for GEE is "robust" when user doesn't specify (detected via length(type) > 1)
- Single coherent type-handling algorithm: length check -> GLM type check -> valid type check
- Existing GLM variance estimation unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Add .get_formula() helper and wire end-to-end pipeline for GEE objects</name>
  <files>R/get_marginal_effect.R</files>
  <action>
This task has two parts: (A) definitively create the `.get_formula()` helper, and (B) verify/fix the end-to-end pipeline for GEE objects.

**Part A: Create .get_formula() helper (MANDATORY -- not conditional)**

Add a `.get_formula()` internal helper function to get_marginal_effect.R (near other internal helpers like `.get_data()`). This helper MUST be created because GEE objects may not have `$formula` accessible the same way as GLM objects.

```r
#' Extract formula from model object
#' @description Safely extracts the formula from a model object, handling
#'   differences between GLM and GEE object structures. GEE objects (glmgee,
#'   geeglm) may store the formula differently from standard glm objects.
#' @param model A fitted model object (glm, glmgee, or geeglm)
#' @return A formula object
#' @keywords internal
.get_formula <- function(model) {
  # Standard GLM objects have $formula

  if (!is.null(model$formula)) return(model$formula)
  # Some model classes store formula in $call$formula
  if (!is.null(model$call$formula)) return(eval(model$call$formula))
  # Fallback: try formula() generic
  tryCatch(
    stats::formula(model),
    error = function(e) {
      stop("Cannot extract formula from model object of class ",
           paste(class(model), collapse = "/"), call. = FALSE)
    }
  )
}
```

**Verification that .get_formula() works for both GEE classes:**

After creating the helper, the executor MUST run this verification BEFORE proceeding to Part B:
```r
# Test .get_formula for glmgee
library(glmtoolbox)
fit_glmgee <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit),
                      data=d, corstr='independence')
frm <- .get_formula(fit_glmgee)
stopifnot(inherits(frm, "formula"))
cat("glmgee formula access: OK\n")

# Test .get_formula for geeglm
library(geepack)
fit_geeglm <- geeglm(aval ~ trtp + bl_cov, id=id, family=binomial(link='logit'),
                      data=d, corstr='independence')
frm <- .get_formula(fit_geeglm)
stopifnot(inherits(frm, "formula"))
cat("geeglm formula access: OK\n")
```

If either fails, debug and fix `.get_formula()` before proceeding.

**Then update all formula access points:**

Replace `object$formula` with `.get_formula(object)` in:
1. get_marginal_effect.R: the line `outcome <- paste(object$formula[[2]])` becomes `outcome <- paste(.get_formula(object)[[2]])`
2. estimate_varcov.R: inside varcov_ge_gee() (Task 1), use `.get_formula(object)` instead of `object$formula`
3. Also check varcov_ge() -- if it uses `object$formula`, update it too for consistency (but only if it doesn't break existing GLM behavior -- GLM objects DO have $formula, so this is safe)

**Part B: Verify end-to-end pipeline**

Verify and fix get_marginal_effect.R so the full pipeline works for GEE objects. The pipeline is:

```r
gee_object |>
  predict_counterfactuals(trt) |>
  average_predictions() |>
  estimate_varcov(strata, method, type, mod) |>
  apply_contrast(contrast, reference)
```

**Check 1: Does the method parameter default work?**
get_marginal_effect has `method = "Ge"` as default. For GEE objects this is correct (Ye is not valid). No change needed here.

**Check 2: Does the type parameter default work?**
get_marginal_effect has `type = "HC0"` as default. For GEE objects, estimate_varcov (after Task 1) will detect `length(type) > 1` in its own default and silently map to "robust". But get_marginal_effect passes `type` as a single string "HC0" (its own default). So estimate_varcov receives length==1 "HC0". This means varcov_ge_gee will hit the `type %in% glm_types` branch and ERROR. Fix: update get_marginal_effect to not pass type when it's the default for GEE objects. OR better: change get_marginal_effect to pass through type unmodified and let estimate_varcov handle it. Check how get_marginal_effect passes type to estimate_varcov -- if it uses the raw argument, the length > 1 detection works. If it resolves to a single value first, we need to handle this differently.

The cleanest fix: in get_marginal_effect, if the object is GEE and type was not explicitly specified by the user, don't pass type (let estimate_varcov use its default). Check if get_marginal_effect uses `missing(type)` or has a fixed default. If it has `type = "HC0"`, we can't detect whether the user specified it. In that case, add GEE-aware handling:
```r
# Before calling estimate_varcov, handle GEE type default
if ((inherits(object, "glmgee") || inherits(object, "geeglm")) && type == "HC0") {
  type <- "robust"
}
```

This silently maps the default HC0 to "robust" for GEE, matching the locked user decision that HC0 should produce an error only when explicitly passed. Since "HC0" is get_marginal_effect's default, this is the non-explicit case.

**Check 3: Does model$xlevels work for GEE?**
apply_contrast uses `object$xlevels[[trt]]` for default reference level. Verify GEE objects have $xlevels. If not, this would error in apply_contrast when reference is not provided. If $xlevels is missing, the user MUST provide an explicit reference. Add a check and informative error in get_marginal_effect if $xlevels is missing and reference is NULL:
```r
if (is.null(object$xlevels) && is.null(reference)) {
  stop("GEE objects may not store xlevels. Please provide the 'reference' argument explicitly.",
       call. = FALSE)
}
```

**Check 4: Does the ARD construction work for GEE?**
get_marginal_effect builds marginal_results tibble accessing:
- `data <- .get_data(object)` -- works for GEE (confirmed in Plan 01)
- `nlevels(data[[trt]])` -- works
- `.get_formula(object)[[2]]` -- works after Part A
- All the counterfactual.means, robust_varcov, marginal_est, marginal_se -- these are added by the pipeline, independent of model class

**Check 5: Class assignment**
`class(object) <- c("beeca", class(object))` -- this should work. A glmgee object might have class c("glmgee", "glm", "lm"). After beeca, it becomes c("beeca", "glmgee", "glm", "lm"). This is fine for S3 dispatch.

**Actual code changes summary:**
1. Add `.get_formula()` helper (MANDATORY)
2. Replace `object$formula` with `.get_formula(object)` in relevant locations
3. Add GEE-aware type default handling in get_marginal_effect
4. Add xlevels fallback check if needed
5. Any other pipeline fixes discovered during verification

**End-to-end verification:**

Run the COMPLETE pipeline for both GEE classes across all 5 contrast types:

```r
contrasts <- c("diff", "or", "rr", "logor", "logrr")
for (contrast in contrasts) {
  result <- get_marginal_effect(gee_object, trt = "trtp", method = "Ge",
                                 contrast = contrast, reference = "A")
  # Verify result has all expected components
  stopifnot(!is.null(result$marginal_est))
  stopifnot(!is.null(result$marginal_se))
  stopifnot(!is.null(result$marginal_results))
  stopifnot(inherits(result, "beeca"))
}
```

Do this for BOTH glmgee and geeglm objects.
  </action>
  <verify>
1. Verify .get_formula() works for both GEE classes:
```
Rscript -e "
devtools::load_all('.')
library(glmtoolbox); library(geepack)
set.seed(42); n <- 50
d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5))
fit1 <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d, corstr='independence')
fit2 <- geeglm(aval ~ trtp + bl_cov, id=id, family=binomial(link='logit'), data=d, corstr='independence')
f1 <- .get_formula(fit1); f2 <- .get_formula(fit2)
stopifnot(inherits(f1, 'formula'), inherits(f2, 'formula'))
cat('Formula access verified for both GEE classes\n')
"
```

2. Full end-to-end test for glmgee with all 5 contrasts:
```
Rscript -e "
devtools::load_all('.')
library(glmtoolbox)
set.seed(42)
n <- 100
d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5))
fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d, corstr='independence')
for (ctr in c('diff','or','rr','logor','logrr')) {
  result <- get_marginal_effect(fit, trt='trtp', method='Ge', contrast=ctr, reference='A')
  cat(sprintf('%s: est=%.6f se=%.6f class=%s\n', ctr, result[['marginal_est']], result[['marginal_se']], paste(class(result), collapse=',')))
}
cat('All 5 contrasts passed for glmgee\n')
"
```

3. Same test for geeglm:
```
Rscript -e "
devtools::load_all('.')
library(geepack)
set.seed(42)
n <- 100
d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5))
fit <- geeglm(aval ~ trtp + bl_cov, id=id, family=binomial(link='logit'), data=d, corstr='independence')
for (ctr in c('diff','or','rr','logor','logrr')) {
  result <- get_marginal_effect(fit, trt='trtp', method='Ge', contrast=ctr, reference='A')
  cat(sprintf('%s: est=%.6f se=%.6f class=%s\n', ctr, result[['marginal_est']], result[['marginal_se']], paste(class(result), collapse=',')))
}
cat('All 5 contrasts passed for geeglm\n')
"
```

4. Verify multi-timepoint GEE data is rejected (validates Plan 05-01 single-timepoint check in end-to-end context):
```
Rscript -e "
devtools::load_all('.')
library(glmtoolbox)
set.seed(42)
n <- 50
d_multi <- data.frame(id=rep(1:(n/2), each=2), trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5))
tryCatch(
  { fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d_multi, corstr='exchangeable')
    result <- get_marginal_effect(fit, trt='trtp', method='Ge', contrast='diff', reference='A')
    cat('ERROR: Should have been rejected\n')
  },
  error = function(e) {
    if (grepl('Multi-timepoint|single-timepoint', e[['message']])) {
      cat('Multi-timepoint rejection: PASS\n')
      cat('Message:', e[['message']], '\n')
    } else {
      cat('Unexpected error:', e[['message']], '\n')
    }
  }
)
"
```

5. Verify marginal_results ARD tibble has expected structure (12 rows for 2-arm trial).

6. Run `Rscript -e "devtools::test('.')"` -- all existing tests pass.

7. Run `Rscript -e "devtools::check('.')"` to verify no new NOTEs/WARNINGs about undocumented S3 methods or missing imports.
  </verify>
  <done>
- .get_formula() helper exists and is verified to work for glmgee, geeglm, and standard glm objects
- All formula access points use .get_formula() instead of direct object$formula
- get_marginal_effect works end-to-end with glmgee for all 5 contrast types (diff, or, rr, logor, logrr)
- get_marginal_effect works end-to-end with geeglm for all 5 contrast types
- Multi-timepoint GEE data is rejected at sanitize_model (validated in end-to-end test)
- Result objects have correct class (beeca, glmgee/geeglm, glm, lm)
- marginal_results ARD tibble has correct structure
- All 308 existing GLM tests pass without modification
- R CMD check produces no new errors or warnings
  </done>
</task>

</tasks>

<verification>
1. Full pipeline works for glmgee: sanitize -> predict_counterfactuals -> average_predictions -> estimate_varcov -> apply_contrast -> get_marginal_effect
2. Full pipeline works for geeglm: same sequence
3. All 5 contrast types produce valid results for both GEE classes
4. Ye method rejection produces exact locked message
5. GLM-style variance types rejected with valid options listed
6. GEE default variance type is "robust"
7. .get_formula() works for glmgee, geeglm, and standard glm
8. Multi-timepoint GEE data rejected with informative error (single-timepoint validation from Plan 05-01)
9. All 308 existing tests pass
10. R CMD check clean (no new errors/warnings)
</verification>

<success_criteria>
Phase 5 success criteria met:
1. A glmgee object passes through sanitize_model and get_marginal_effect returns marginal treatment effects for all 5 contrast types
2. A geeglm object passes through sanitize_model and get_marginal_effect returns marginal treatment effects for all 5 contrast types
3. estimate_varcov with GEE uses GEE's own vcov (robust, bias-corrected, df-adjusted for glmgee)
4. method="Ye" on GEE produces informative error
5. Invalid GEE objects produce clear error messages
6. .get_formula() guarantees formula access for all supported model classes
7. Multi-timepoint GEE data is rejected at validation stage
</success_criteria>

<output>
After completion, create `.planning/phases/05-gee-core-implementation/05-02-SUMMARY.md`
</output>
