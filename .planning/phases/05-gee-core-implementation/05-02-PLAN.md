---
phase: 05-gee-core-implementation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - R/estimate_varcov.R
  - R/get_marginal_effect.R
autonomous: true

must_haves:
  truths:
    - "estimate_varcov with a GEE object uses GEE's own vcov (not sandwich::vcovHC)"
    - "GEE variance types use GEE-native names (robust, bias-corrected, df-adjusted), not HC0/HC1/etc."
    - "Passing HC0 to a GEE object produces an error listing valid GEE types"
    - "method='Ye' with a GEE object produces: Ye's method assumes independence and is not valid for GEE models. Use method='Ge' instead."
    - "get_marginal_effect works end-to-end with glmgee for all five contrast types"
    - "get_marginal_effect works end-to-end with geeglm for all five contrast types"
  artifacts:
    - path: "R/estimate_varcov.R"
      provides: "GEE variance routing via varcov_ge_gee internal function"
      contains: "varcov_ge_gee"
    - path: "R/estimate_varcov.R"
      provides: "Ye method rejection for GEE"
      contains: "Ye's method assumes independence"
    - path: "R/get_marginal_effect.R"
      provides: "End-to-end pipeline for GEE objects"
      contains: "get_marginal_effect"
  key_links:
    - from: "R/estimate_varcov.R"
      to: "vcov(object, type = ...)"
      via: "GEE-native vcov call instead of sandwich::vcovHC"
      pattern: "vcov\\(object.*type"
    - from: "R/estimate_varcov.R"
      to: "varcov_ge"
      via: "delta method reuse -- same d_list computation, different V source"
      pattern: "all_d.*%\\*%.*V.*%\\*%.*t\\(all_d\\)"
    - from: "R/get_marginal_effect.R"
      to: "R/estimate_varcov.R"
      via: "pipeline passes GEE object through estimate_varcov"
      pattern: "estimate_varcov"
---

<objective>
Add GEE variance routing to estimate_varcov and verify the end-to-end pipeline produces correct marginal treatment effects for GEE objects across all five contrast types.

Purpose: This completes the GEE core implementation. Plan 01 opened the gate (validation). This plan wires the variance estimation correctly and confirms the full pipeline works: GEE object -> predict_counterfactuals -> average_predictions -> estimate_varcov -> apply_contrast -> marginal results.

Output: Modified estimate_varcov.R with GEE routing, any needed tweaks to get_marginal_effect.R, verified end-to-end pipeline.
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gee-core-implementation/05-CONTEXT.md
@.planning/phases/05-gee-core-implementation/05-RESEARCH.md
@.planning/phases/05-gee-core-implementation/05-01-SUMMARY.md
@R/estimate_varcov.R
@R/get_marginal_effect.R
@R/sanitize.R
@R/predict_counterfactuals.R
@R/apply_contrast.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GEE variance routing to estimate_varcov</name>
  <files>R/estimate_varcov.R</files>
  <action>
Modify estimate_varcov() and add a new internal function varcov_ge_gee() for GEE variance estimation. The changes are surgical -- the delta method math is identical to existing varcov_ge(), only the V (variance-covariance of coefficients) source changes.

**Changes to estimate_varcov():**

1. After `method <- match.arg(method)`, add early Ye rejection for GEE objects:
   ```r
   if (method == "Ye" && (inherits(object, "glmgee") || inherits(object, "geeglm"))) {
     stop("Ye's method assumes independence and is not valid for GEE models. Use method='Ge' instead.",
          call. = FALSE)
   }
   ```
   This exact message is a locked user decision. Do not modify it.

2. In the `method == "Ge"` branch, BEFORE calling match.arg(type) with the GLM HC types, detect GEE objects and route differently:
   ```r
   if (method == "Ge") {
     if (inherits(object, "glmgee") || inherits(object, "geeglm")) {
       # GEE objects use GEE-native variance types, not HC types
       varcov <- varcov_ge_gee(object, trt, type)
     } else {
       type <- match.arg(type)
       if (!is.null(strata)) {
         warning("Strata is supplied but will be ignored when using method='Ge'", call. = FALSE)
       }
       varcov <- varcov_ge(object, trt, type)
     }
   }
   ```

3. Update the type attribute on robust_varcov to reflect GEE type names:
   The existing line `attr(object$robust_varcov, "type") <- ifelse(method == "Ge", paste0(method, " - ", type), method)` should still work because `type` will contain the GEE-native type name.

**New internal function varcov_ge_gee():**

```r
## GEE-specific Ge delta method variance
## Uses GEE's own vcov instead of sandwich::vcovHC
varcov_ge_gee <- function(object, trt, type) {
  data <- .get_data(object)

  # Determine valid variance types based on GEE class
  if (inherits(object, "glmgee")) {
    valid_types <- c("robust", "bias-corrected", "df-adjusted")
    default_type <- "robust"
    class_name <- "glmgee"
  } else if (inherits(object, "geeglm")) {
    valid_types <- c("robust")
    default_type <- "robust"
    class_name <- "geeglm"
  }

  # Handle default: if type is one of the GLM HC types (user passed nothing or GLM default),
  # use GEE default. The estimate_varcov signature has type = c("HC0", ...) as default,
  # so type will be "HC0" if user didn't specify. Map it to GEE default.
  glm_types <- c("HC0", "model-based", "HC3", "HC", "HC1", "HC2", "HC4", "HC4m", "HC5")
  if (type %in% glm_types) {
    # Check if user explicitly passed a GLM type (not just the default)
    # We can tell because match.arg hasn't been called yet for GEE path
    # If type == "HC0" it's likely the default; use GEE default silently
    # If type is any other GLM type, the user explicitly chose it -- error
    if (type != "HC0") {
      stop(sprintf(
        'Variance type "%s" is not supported for %s objects. Valid types: %s',
        type, class_name, paste(valid_types, collapse = ", ")
      ), call. = FALSE)
    }
    type <- default_type
  }

  # Validate GEE type
  if (!type %in% valid_types) {
    stop(sprintf(
      'Variance type "%s" is not supported for %s objects. Valid types: %s',
      type, class_name, paste(valid_types, collapse = ", ")
    ), call. = FALSE)
  }

  # Get GEE's own variance-covariance matrix of coefficients
  if (inherits(object, "geeglm")) {
    # geeglm: vcov() returns the sandwich variance from fitting
    # The type is determined by std.err at fit time, so just use vcov()
    V <- stats::vcov(object)
  } else {
    # glmgee: vcov(object, type = ...) supports multiple types
    V <- vcov(object, type = type)
  }

  # Delta method -- IDENTICAL to existing varcov_ge() from here
  cf_pred <- object$counterfactual.predictions

  d_list <- list()
  for (trtlvl in levels(data[[trt]])) {
    X_i <- data
    X_i[, trt] <- factor(trtlvl, levels = levels(data[[trt]]))
    X_i <- model.matrix(object$formula, X_i)

    pderiv_i <- cf_pred[, trtlvl] * (1 - cf_pred[, trtlvl])
    d_i <- (t(pderiv_i) %*% as.matrix(X_i)) / nrow(X_i)
    d_list[[trtlvl]] <- d_i
  }

  all_d <- do.call(rbind, d_list)
  varcov <- all_d %*% V %*% t(all_d)
  rownames(varcov) <- colnames(varcov) <- levels(data[[trt]])

  return(varcov)
}
```

**Design decisions (Claude's discretion per CONTEXT.md):**
- Default variance type for GEE: "robust" (matches sandwich HC0 philosophy, consistent recommendation from research)
- geeglm variance: expose only "robust" (native geepack sandwich SE). The std.err type is set at fit time, and vcov() returns whatever was specified. Exposing only "robust" avoids confusion -- users who want different corrections should specify std.err when fitting.
- glmgee variance: expose "robust", "bias-corrected", "df-adjusted" (all three work per feasibility testing; "model" and "jackknife" omitted for simplicity -- "model" is naive/anti-conservative, "jackknife" is computationally expensive)
- Type mapping: when user passes HC0 (the default from estimate_varcov signature), silently map to "robust". When user passes any OTHER GLM type (HC1, HC3, etc.), error with valid options list. This is because HC0 is the default and users won't have explicitly chosen it.
- vcov extraction: use vcov() method call (not object internals) -- cleaner, more future-proof

**IMPORTANT: The `type` parameter in estimate_varcov has GLM defaults in the signature.**

The function signature is `type = c("HC0", "model-based", ...)`. When a GEE user calls `estimate_varcov(gee_obj, method = "Ge")` without specifying type, R's match.arg would normally resolve to "HC0". But we intercept BEFORE match.arg for GEE objects. This means `type` will be the raw character vector `c("HC0", "model-based", ...)` if not specified. Handle this: if `length(type) > 1`, the user didn't specify type, so use GEE default. If `length(type) == 1`, the user specified something.

Revise the type handling:
```r
# If type wasn't explicitly specified (still the full default vector), use GEE default
if (length(type) > 1) {
  type <- default_type
} else if (type %in% glm_types) {
  # User explicitly passed a GLM type name
  stop(sprintf(
    'Variance type "%s" is not supported for %s objects. Valid types: %s',
    type, class_name, paste(valid_types, collapse = ", ")
  ), call. = FALSE)
} else if (!type %in% valid_types) {
  stop(sprintf(
    'Variance type "%s" is not supported for %s objects. Valid types: %s',
    type, class_name, paste(valid_types, collapse = ", ")
  ), call. = FALSE)
}
```

**Also handle strata warning for GEE:**

If strata is supplied with a GEE object, warn that it's ignored (same as existing Ge method behavior).
  </action>
  <verify>
1. Run `Rscript -e "devtools::load_all('.'); library(glmtoolbox); set.seed(42); n <- 50; d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5)); fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d, corstr='independence'); result <- fit |> predict_counterfactuals('trtp') |> average_predictions() |> estimate_varcov(method='Ge'); cat('glmgee varcov computed\n'); print(result[['robust_varcov']])"` -- should print a 2x2 variance-covariance matrix.

2. Test Ye rejection: `Rscript -e "devtools::load_all('.'); library(glmtoolbox); set.seed(42); n <- 50; d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5)); fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d, corstr='independence'); result <- fit |> predict_counterfactuals('trtp') |> average_predictions(); tryCatch(estimate_varcov(result, method='Ye'), error=function(e) cat('Error:', e[['message']], '\n'))"` -- should print the Ye rejection message.

3. Test GLM type rejection: similar test passing `type='HC3'` to a GEE object -- should error with valid types list.

4. Run `Rscript -e "devtools::test('.')"` -- all existing tests pass.
  </verify>
  <done>
- estimate_varcov routes GEE objects to varcov_ge_gee() which uses GEE's own vcov
- Ye method with GEE produces exact locked error message
- GLM variance types (HC0, HC3, etc.) rejected for GEE with valid options listed
- Default type for GEE is "robust" when user doesn't specify
- Existing GLM variance estimation unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire and verify end-to-end pipeline for GEE objects</name>
  <files>R/get_marginal_effect.R</files>
  <action>
Verify and fix get_marginal_effect.R so the full pipeline works for GEE objects. The pipeline is:

```r
gee_object |>
  predict_counterfactuals(trt) |>
  average_predictions() |>
  estimate_varcov(strata, method, type, mod) |>
  apply_contrast(contrast, reference)
```

**Check 1: Does the method parameter default work?**

get_marginal_effect has `method = "Ge"` as default. For GEE objects this is correct (Ye is not valid). No change needed here.

**Check 2: Does the type parameter default work?**

get_marginal_effect has `type = "HC0"` as default. For GEE objects, estimate_varcov (after Task 1) will detect this as the default and silently map to "robust". This should work. But verify: does get_marginal_effect pass `type` through to estimate_varcov correctly? Yes -- it passes it directly in the pipeline.

**Check 3: Does the formula attribute work for GEE?**

get_marginal_effect accesses `object$formula` on line `outcome <- paste(object$formula[[2]])`. Verify this works for both glmgee and geeglm. If either stores the formula differently (e.g., as $call$formula), add a conditional:
```r
# Extract formula -- GEE objects may store formula differently
if (is.null(object$formula)) {
  formula_obj <- object$call$formula
} else {
  formula_obj <- object$formula
}
outcome <- paste(formula_obj[[2]])
```

Also check the line `model.matrix(object$formula, X_i)` in varcov_ge_gee -- same concern.

**Check 4: Does model$xlevels work for GEE?**

apply_contrast uses `object$xlevels[[trt]]` for default reference level. Verify GEE objects have $xlevels. If not, this would error in apply_contrast when reference is not provided. If $xlevels is missing, get_marginal_effect should still work if the user provides an explicit reference. Document this or add a fallback.

**Check 5: Does the ARD construction work for GEE?**

get_marginal_effect builds marginal_results tibble accessing:
- `data <- .get_data(object)` -- works for GEE
- `nlevels(data[[trt]])` -- works
- `object$formula[[2]]` -- check per above
- All the counterfactual.means, robust_varcov, marginal_est, marginal_se -- these are added by the pipeline, independent of model class

**Check 6: Class assignment**

`class(object) <- c("beeca", class(object))` -- this should work. A glmgee object might have class c("glmgee", "glm", "lm"). After beeca, it becomes c("beeca", "glmgee", "glm", "lm"). This is fine for S3 dispatch.

**Actual code changes (if needed):**

Only make changes if the checks above reveal actual issues. The goal is MINIMAL changes. If everything works, this task is about verification with actual running code, not code changes.

If formula access needs fixing, add a `.get_formula()` internal helper:
```r
.get_formula <- function(model) {
  if (!is.null(model$formula)) return(model$formula)
  if (!is.null(model$call$formula)) return(eval(model$call$formula))
  stop("Cannot extract formula from model object", call. = FALSE)
}
```
And use it in get_marginal_effect.R and estimate_varcov.R where object$formula is accessed.

**End-to-end verification:**

Run the COMPLETE pipeline for both GEE classes across all 5 contrast types:

```r
contrasts <- c("diff", "or", "rr", "logor", "logrr")
for (contrast in contrasts) {
  result <- get_marginal_effect(gee_object, trt = "trtp", method = "Ge",
                                 contrast = contrast, reference = "A")
  # Verify result has all expected components
  stopifnot(!is.null(result$marginal_est))
  stopifnot(!is.null(result$marginal_se))
  stopifnot(!is.null(result$marginal_results))
  stopifnot(inherits(result, "beeca"))
}
```

Do this for BOTH glmgee and geeglm objects.
  </action>
  <verify>
1. Full end-to-end test for glmgee with all 5 contrasts:
```
Rscript -e "
devtools::load_all('.')
library(glmtoolbox)
set.seed(42)
n <- 100
d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5))
fit <- glmgee(aval ~ trtp + bl_cov, id=id, family=binomial(logit), data=d, corstr='independence')
for (ctr in c('diff','or','rr','logor','logrr')) {
  result <- get_marginal_effect(fit, trt='trtp', method='Ge', contrast=ctr, reference='A')
  cat(sprintf('%s: est=%.6f se=%.6f class=%s\n', ctr, result[['marginal_est']], result[['marginal_se']], paste(class(result), collapse=',')))
}
cat('All 5 contrasts passed for glmgee\n')
"
```

2. Same test for geeglm:
```
Rscript -e "
devtools::load_all('.')
library(geepack)
set.seed(42)
n <- 100
d <- data.frame(id=1:n, trtp=factor(rep(c('A','B'), each=n/2)), bl_cov=rnorm(n), aval=rbinom(n,1,0.5))
fit <- geeglm(aval ~ trtp + bl_cov, id=id, family=binomial(link='logit'), data=d, corstr='independence')
for (ctr in c('diff','or','rr','logor','logrr')) {
  result <- get_marginal_effect(fit, trt='trtp', method='Ge', contrast=ctr, reference='A')
  cat(sprintf('%s: est=%.6f se=%.6f class=%s\n', ctr, result[['marginal_est']], result[['marginal_se']], paste(class(result), collapse=',')))
}
cat('All 5 contrasts passed for geeglm\n')
"
```

3. Verify marginal_results ARD tibble has expected structure (12 rows for 2-arm trial).

4. Run `Rscript -e "devtools::test('.')"` -- all existing tests pass.

5. Run `Rscript -e "devtools::check('.')"` to verify no new NOTEs/WARNINGs about undocumented S3 methods or missing imports.
  </verify>
  <done>
- get_marginal_effect works end-to-end with glmgee for all 5 contrast types (diff, or, rr, logor, logrr)
- get_marginal_effect works end-to-end with geeglm for all 5 contrast types
- Result objects have correct class (beeca, glmgee/geeglm, glm, lm)
- marginal_results ARD tibble has correct structure
- All 308 existing GLM tests pass without modification
- R CMD check produces no new errors or warnings
  </done>
</task>

</tasks>

<verification>
1. Full pipeline works for glmgee: sanitize -> predict_counterfactuals -> average_predictions -> estimate_varcov -> apply_contrast -> get_marginal_effect
2. Full pipeline works for geeglm: same sequence
3. All 5 contrast types produce valid results for both GEE classes
4. Ye method rejection produces exact locked message
5. GLM-style variance types rejected with valid options listed
6. GEE default variance type is "robust"
7. All 308 existing tests pass
8. R CMD check clean (no new errors/warnings)
</verification>

<success_criteria>
Phase 5 success criteria met:
1. A glmgee object passes through sanitize_model and get_marginal_effect returns marginal treatment effects for all 5 contrast types
2. A geeglm object passes through sanitize_model and get_marginal_effect returns marginal treatment effects for all 5 contrast types
3. estimate_varcov with GEE uses GEE's own vcov (robust, bias-corrected, df-adjusted for glmgee)
4. method="Ye" on GEE produces informative error
5. Invalid GEE objects produce clear error messages
</success_criteria>

<output>
After completion, create `.planning/phases/05-gee-core-implementation/05-02-SUMMARY.md`
</output>
